<!DOCTYPE html>
<meta charset="utf-8">
<style>

.overlay {
  fill: none;
  pointer-events: all;
}

ellipse {
	fill: gray;
	stroke: black;
	fill-opacity: 0.1;
	stroke-opacity: 0.2;
}

ellipse:hover {
	fill-opacity: 0.2;
}

</style>
<body>

	<div id="svgpath"></div>
	
<script src="http://mbostock.github.com/d3/d3.js?2.7.2"></script>
<script>

	// var host_path = 'localhost';
	var host_path = 'emo2.trinity.duke.edu';
	
	var x_extent, y_extent, x_diff, y_diff, diff_max;
	var divElem2 = d3.select("#svgpath");
	var circle;
	var width = 800;
	var height = 800;
	
	var x_scale = d3.scale.linear().range([0,width]);
	var y_scale = d3.scale.linear().range([0,height]);
	var xr_scale = d3.scale.linear().range([0,width]);
	var yr_scale = d3.scale.linear().range([0,height]);

	var transformit = function(d) {
				return "translate(" + x_scale(d[0]) + "," + y_scale(d[1]) + ")";
			};

	var svgcanvas2 = divElem2.append("svg:svg")
				.attr("width", width)
				.attr("height", height);
	
	d3.json('http://' + host_path + '/remote/netpathcoords', function(netpathdata) {
		d3.json('http://' + host_path + '/remote/globalpathcoords', function(data) {
			d3.json('http://' + host_path + '/remote/allellipses', function(ellipse_data) {
		
		var eldata = ellipse_data.data;
		var bounds = ellipse_data.bounds;
		
		x_scale.domain(bounds[0]);
		y_scale.domain(bounds[1]);
		xr_scale.domain([0, bounds[0][1]-bounds[0][0]]);
		xr_scale.domain([0, bounds[1][1]-bounds[1][0]]);

		// Specify the function for generating path data             
		var lineFunction = d3.svg.line()
										.x(function(d){return x_scale(d[0]);})
										.y(function(d){return y_scale(d[1]);})
										.interpolate("linear");
										// .defined(function(d,i){ return (i%1)!=0; }); 

		
		// Update the ellipses
		// data = [[X, Y, RX, RY, Phi, i], ...]
		svgcanvas2.selectAll("ellipse")
				.data(eldata, function(d){return d[5];})
			.enter()
				.append("ellipse")
				.attr("transform", function(d){return "translate(" + x_scale(d[0]) + "," + y_scale(d[1]) + ")  rotate(" + d[4] + ")";})
				.attr("rx", function(d) { return xr_scale(d[2]); })
				.attr("ry", function(d) { return yr_scale(d[3]); });

		// Creating net path
		svgcanvas2.append("svg:path")
				.attr("d", lineFunction(netpathdata))
				.style("stroke-width", 1.5)
				.style("stroke-opacity", 0.2)
				.style("stroke", "black")
				.style("fill", "none");
		
		// Creating actual path
		svgcanvas2.append("svg:path")
				.attr("d", lineFunction(data))
				.style("stroke-width", 1.5)
				.style("stroke-opacity", 0.8)
				.style("stroke", "saddlebrown")
				.style("fill", "none");

	  	});
  	});
  });

</script>
</body>
</html>
